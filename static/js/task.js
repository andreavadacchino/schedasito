document.addEventListener('DOMContentLoaded', function () {    const taskListTbody = document.getElementById('task-list-tbody');    const newTaskButton = document.getElementById('new-task-button');    const taskModal = document.getElementById('task-modal');    const taskForm = document.getElementById('task-form');    const cancelTaskButton = document.getElementById('cancel-task-button');    const modalTitle = document.getElementById('modal-title');    const errorNotificationArea = document.getElementById('error-notification-area');    const successNotificationArea = document.getElementById('success-notification-area');    // Form fields    const taskIdInput = document.getElementById('task-id-input');    const taskProjectSelect = document.getElementById('task-project-select');    const taskNameInput = document.getElementById('task-name-input');    const taskDescriptionInput = document.getElementById('task-description-input');    const taskAssigneeSelect = document.getElementById('task-assignee-select');    const taskDueDateInput = document.getElementById('task-due-date-input');    const taskStatusSelect = document.getElementById('task-status-select');    function showError(message) {        errorNotificationArea.textContent = message;        errorNotificationArea.style.display = 'block';        successNotificationArea.style.display = 'none';        setTimeout(() => { errorNotificationArea.style.display = 'none'; }, 5000);    }    function showSuccess(message) {        successNotificationArea.textContent = message;        successNotificationArea.style.display = 'block';        errorNotificationArea.style.display = 'none';        setTimeout(() => { successNotificationArea.style.display = 'none'; }, 3000);    }    async function fetchApi(url, options = {}) {        options.credentials = 'include';        options.headers = {            'Content-Type': 'application/json',            'Accept': 'application/json',            ...options.headers,        };        try {            const response = await fetch(url, options);            if (!response.ok) {                if (response.status === 401 || response.status === 403) {                    showError("Sessione scaduta o non autorizzato. Verrai reindirizzato alla pagina di login.");                    setTimeout(() => { window.location.href = '/login_page'; }, 3000);                    return null;                }                const errorData = await response.json().catch(() => ({ message: `Errore ${response.status}` }));                showError(errorData.message || `Errore ${response.status}`);                return null;            }            return response.status === 204 ? {} : await response.json();        } catch (error) {            showError(`Errore di rete: ${error.message}`);            return null;        }    }    function getStatusBadgeClass(status) {        const statusClasses = {            'Non Iniziato': 'status-todo',            'In Corso': 'status-inprogress',            'Completato': 'status-done',            'In Revisione': 'status-inrevisione',            'Archiviato': 'status-archiviato'        };        return statusClasses[status] || 'bg-slate-200 text-slate-600';    }    async function loadTasks() {        taskListTbody.innerHTML = '<tr><td colspan="6" class="text-center p-4">Caricamento task...</td></tr>';        const tasks = await fetchApi('/api/tasks');        if (tasks && Array.isArray(tasks)) {            taskListTbody.innerHTML = ''; // Clear loading row            if (tasks.length === 0) {                taskListTbody.innerHTML = '<tr><td colspan="6" class="text-center p-4">Nessun task trovato.</td></tr>';                return;            }            tasks.forEach(task => {                const row = taskListTbody.insertRow();                row.className = 'hover:bg-slate-50 transition-colors';                row.insertCell().textContent = task.name || 'N/A';                row.insertCell().textContent = task.project_name || 'N/A'; // Assuming API provides this                row.insertCell().textContent = task.assignee_name || 'Non assegnato'; // Assuming API provides this                row.insertCell().textContent = task.due_date ? new Date(task.due_date).toLocaleDateString() : 'N/D';                const statusCell = row.insertCell();                const statusBadge = document.createElement('span');                statusBadge.className = `status-badge ${getStatusBadgeClass(task.status)}`;                statusBadge.textContent = task.status;                statusCell.appendChild(statusBadge);                const actionsCell = row.insertCell();                actionsCell.className = 'h-[72px] px-5 py-3 text-slate-500';                const editButton = document.createElement('button');                editButton.innerHTML = '<span class="material-icons text-slate-500 hover:text-blue-500">edit</span>';                editButton.title = "Modifica Task";                editButton.classList.add('mr-2');                editButton.onclick = () => openTaskModal(task);                actionsCell.appendChild(editButton);                const deleteButton = document.createElement('button');                deleteButton.innerHTML = '<span class="material-icons text-slate-500 hover:text-red-500">delete</span>';                deleteButton.title = "Elimina Task";                deleteButton.onclick = () => deleteTask(task.id, task.name);                actionsCell.appendChild(deleteButton);            });        } else {            taskListTbody.innerHTML = '<tr><td colspan="6" class="text-center p-4 text-red-500">Errore nel caricamento dei task.</td></tr>';        }    }    async function populateModalDropdowns() {        // Populate Projects        const projects = await fetchApi('/api/projects');        if (projects && Array.isArray(projects)) {            taskProjectSelect.innerHTML = '<option value="">Seleziona un progetto</option>';            projects.forEach(project => {                const option = document.createElement('option');                option.value = project.id;                option.textContent = project.name;                taskProjectSelect.appendChild(option);            });        }        // Populate Users (Assignees)        const users = await fetchApi('/api/users');        if (users && Array.isArray(users)) {            taskAssigneeSelect.innerHTML = '<option value="">Non assegnato</option>';            users.forEach(user => {                const option = document.createElement('option');                option.value = user.id;                option.textContent = user.name || user.username;                taskAssigneeSelect.appendChild(option);            });        }    }    function openTaskModal(task = null) {        taskForm.reset();        taskIdInput.value = '';        populateModalDropdowns(); // Populate dropdowns each time modal is opened        if (task) {            modalTitle.textContent = 'Modifica Task';            taskIdInput.value = task.id;            taskProjectSelect.value = task.project_id || '';            taskNameInput.value = task.name || '';            taskDescriptionInput.value = task.description || '';            taskAssigneeSelect.value = task.assignee_id || '';            taskDueDateInput.value = task.due_date ? task.due_date.split('T')[0] : '';            taskStatusSelect.value = task.status || 'Non Iniziato';            taskProjectSelect.disabled = true; // Cannot change project when editing a task        } else {            modalTitle.textContent = 'Nuovo Task';            taskProjectSelect.disabled = false;        }        taskModal.style.display = 'flex';    }    function closeTaskModal() {        taskModal.style.display = 'none';    }    async function handleTaskFormSubmit(event) {        event.preventDefault();        const taskId = taskIdInput.value;        const projectId = taskProjectSelect.value;        if (!projectId && !taskId) { // Project is required for new tasks            showError("Seleziona un progetto per il nuovo task.");            return;        }        const taskData = {            name: taskNameInput.value,            description: taskDescriptionInput.value,            assignee_id: taskAssigneeSelect.value || null, // Send null if empty            due_date: taskDueDateInput.value || null,            status: taskStatusSelect.value,        };        let result;        if (taskId) { // Editing existing task            result = await fetchApi(`/api/tasks/${taskId}`, {                method: 'PUT',                body: JSON.stringify(taskData),            });        } else { // Creating new task            taskData.project_id = projectId; // project_id is part of the body for new tasks if API expects it this way            // Or use the URL: /api/projects/${projectId}/tasks            // I noted that the API call needs to be structured for POST /api/projects/<project_id>/tasks            // So, the API call needs to be structured accordingly.            result = await fetchApi(`/api/projects/${projectId}/tasks`, {                method: 'POST',                body: JSON.stringify(taskData),            });        }        if (result) {            showSuccess(`Task ${taskId ? 'aggiornato' : 'creato'} con successo!`);            closeTaskModal();            loadTasks(); // Refresh task list        } else {            showError(`Errore durante il salvataggio del task.`);        }    }    async function deleteTask(taskId, taskName) {        if (confirm(`Sei sicuro di voler eliminare il task "${taskName || 'senza nome'}"?`)) {            const result = await fetchApi(`/api/tasks/${taskId}`, { method: 'DELETE' });            if (result) {                showSuccess(`Task "${taskName}" eliminato con successo.`);                loadTasks(); // Refresh task list            } else {                showError("Errore durante l'eliminazione del task.");            }        }    }    // Event Listeners    newTaskButton.addEventListener('click', () => openTaskModal());    cancelTaskButton.addEventListener('click', closeTaskModal);    taskModal.addEventListener('click', (event) => { // Close modal if backdrop is clicked        if (event.target === taskModal) {            closeTaskModal();        }    });    taskForm.addEventListener('submit', handleTaskFormSubmit);    // Initial load    loadTasks();});